stil(standard test interface language) format
ググったらMicross Components, inc.の以下資料が引っ掛かったのでDeepL翻訳でざっくり翻訳した後読み込んだのでメモ。
https://shop.micross.com/pdf/Micross_Technical_Paper-STIL_Language_Test_Vector_Format_Simplified.pdf

Micross Components, inc.って初めて聞いたけど、どうもアメリカの会社で半導体関連の業務をいろいろとやってる会社みたい。
https://www.micross.com/

日本法人は無く、半導体商社のJEPICOが代理店やっているみたい。会社概要飛ぶとJEPICOの会社概要しか出ないのでよくわからない。
https://www.jepico.co.jp/company.html

単語とか
signal block
ピン信号の定義
timing block/waveforme table
信号のタイミングセットを波形のフォーマット
dclevels block
DUTに印加・出力されるDC信号レベル（VIL/VIH、VOL/VOH）を定義する
pattern block
テストベクターの定義。
signal group block
バス、制御信号などの各種端子をまとめる
pattern burst bloc
複数のパターンブロックを一連のパタンにリンクさせる
pattern exec block
バーストブロックをい必要なDCレベルやタイミングセットでつなぐ


Syntax
Signals
信号の定義を行う。
Signals {
 ( SigName ( In | Out | InOut | Supply | Pseudo ) ( ; | 
 ( { ( ScanIn | ScanOut ) ;} ) ) )* 
( WFCMap { 
  ( FROM_WFC -> TO_WFC( TO_WFC )+ ; )* 
  ( FROM_WFC1 FROM_WFC2 -> TO_WFC ; )* 
  } ) 
 )*)* 
}

SigName = 信号名
In = 入力として定義
Out = 出力として定義
InOut = 双方向として定義
Supplu = 電源またはGNDを定義する
Pseudo = 信号がデバイスピンでない場合に使用
ScanIn = Scan入力
ScanOut = Scan出力

Signals {
 "pc4" InOut;
 irq InOut;
 scan0 In { ScanIn; }
}


SignalGroups
0個以上の信号グループへの名前付き参照を作成するために使用される。
SignalGroups {
 ( GroupName = '( SigName | GroupName ) ( + ( SigName | GroupName ) )*' ; | 
 ( WFCMap { 
 ( FROM_WFC -> TO_WFC( TO_WFC )+ ; )* 
 ( FROM_WFC1 FROM_WFC2 -> TO_WFC ; )* 
 } ) 
 )*)* 
}

GroupName = 信号グループ名
SigName = 信号名
WFCMap = ブロックはWaveformCharacterの値をほかのWaveformCharacterにマッピングする。
FROM_WFC = 別のWaveformCharacterにマップされるWaveFormCharacter。
FROM_WFC1 = 別のWaveformCharacterにマップされる最初のWaveformCharacter。
FROM_WFC2 = 〃2番目のWaveformCharacter。
TO_WFC = WaveFormcharacterの代用として使用するWaveformCharacterまたはそのリスト。

ここで言ってるマップっていうのはaliasみたいなものか？
実タイプのStilにはGroupNameなどの定義しかなく、あんまり参考にならなかったのでドキュメントから抜粋。
SignalGroups { 
    "porta" = ` "pa7" + "pa6" + "pa5" + "pa4" + "pa3" + "pa2" + "pa1" + "pa0" ` ;  // GroupNameとそのGroupに所属する信号の定義。
    "portb" = ` "pb7" + "pb6" + "pb5" + "pb4" + "pb3" + "pb2" + "pb1" + "pb0" ` ;  // GroupNameとそのGroupに所属する信号の定義。
    all = `porta + portb';  // Groupをまとめることもできる
    
    A = `pa0+pa1+pa2+pa3' { 
        WFCMap { 
            z->x; //single-WFC mapping 
            01->x;//two-WFC mapping (requires presence of \j) 
         } // end WFCMap 
    } // end A 
} 

Timing Block / Waveform Table
Timing Blockはタイミングエッジの配置と、Vector文の信号に波形文字を適用した参照させる周期的な波形のフォーマットを定義する。
1つ以上のWaveformTable（WFTS）を含むことができ、各ブロックはperiodをWaveformsのコレクションから構成されている。

Timing TimingName {
    ( WaveformTable TableName { 
        Period TimeExpr ;
            Waveforms { 
                (SigName { 
                    (WFC)* { 
                    ( TimeExpr (Event ( | Event)* ); )* 
                } )* 
            } )* 
        } 
    } 
} 

TimingName = Timingブロックの名前
 TableName = WaveformTableブロックの名前
Period = 周期
SigName = 信号名
WFC = パタンに使用する波形文字列を定義。波形文字は [9-0] | [a-z] | [A-Z] の英語一文字である必要がある。
TimeExpr = (integer | float) (engineering_prefix) (unit) イベントを定義するっぽい。ここだけ何の説明もない。。発生時刻に続いて起こるイベントをWFCで記載する。連続して記載しても可。
Event = 
D | ForceDown - VILを強制的に下げる。（入力をLOWに落とす？）
U | ForceUp - VIHの値を強制的に変更する。（入力をHIGHに上げる？）
Z | ForceOff - ドライバモードがHiZの時、ドライバをOffにする。ドライバモードがVIHHの時、強制的にVIHHにする。（ちょっとVIHHがよくわからないのであれだけど。。ドライバ側（テスタ）の出力がオープン状態の時、HiZになる設定の場合はOffのHiZ状態、VIHHの時はVIHの電圧（HIGH）に合わせるって意味と理解した）
N | ForceUnknown - Uフォーマットと同じ。ForceUP
L | CompareLow - VOLより低い電圧で比較する。LOW期待値。
H | CompareHigh - VOHより高い電圧で比較する。HIGH期待値
X | CompareUnknown - Don't care。期待値を持たせない。
T | CompareOff - VOHとVOLの間の値を比較する。中間電位で比較？

ちなみに以下
VIH
入力電圧をHIGHと認識する電圧。
VIL
入力電圧をLOWと認識する電圧
VOH
出力電圧のHIGH
VOL
出力電圧のLOW
HiZ
信号が駆動されていない出力状態。他のデバイスによって駆動される(または未定義状態を避けるために提供される抵抗によってプルアップまたはプルダウンされる)ハイインピーダンス状態のこと。
3ステートなどのハイインピーダンス方式はバスによく使われる。バスを駆動するために複数のデバイスを選択することができる。
信号はオープン状態にすることで、他の出力ピン(バス上の他のどこか)が信号を駆動することができる。あるいは信号レベルは受動デバイス(通常、プルアップ抵抗)によって決定可能。
回路が開放されている(オープン)状態である、つまり断線している状態である。断線させる目的には様々あるが、例えば複数の機器が接続されるような場合、複数の信号線が同時に機能していては正常に動作できないので、アクセスするもの以外の接続は切断する必要がある。このとき、ハイインピーダンスにすることで使用しない信号線を切り離すことになる。
「バスをくどうさせるために～」のくだりがよくわからなかったので複数サイトからコピペ。最後の文章が一番端的な気がする。
VIHH
よくわからん。ググっても出てこない。「調整用ハイレベル」って言葉は引っ掛かった。
VILL
上におなじ。「調整用ローレベル」って言葉が引っ掛かった。

Timing "Param_Time_Set" { 
    WaveformTable "T1" { 
        Period '100nS'; 
        Waveforms { 
            // functional continuity timing... 
            "Control_pins" { 0 { '45nS' D; }} // 45nsのところでVIHを下げる（LOW入力にする）
            "Control_pins" { 1 { '50nS' U; }} 
            "Data_pins" { 0 { '10ns' D; '70nS' U; }} 
            "Data_Pins" { 1 { '15nS' U; '75nS' D; }} 
            "Clock_pins" { 1 { '15ns' U; '75nS' D; }} 
            "Clock_pins" { 0 { '15ns' D; }} 
        } 
    } 
}




PDF記載のSTILを読み込むと以下のような波形となる。

ピングループ”Control_pins”はグループ内の核ピンのベクタパターンが1の時、50nsでHIGHになり、前のベクタがすでにHIGHだった場合はエッジは発生しない。そのピンのパタンに”0”がある場合、45nsでLOWになり、前のベクトルが0の場合、エッジは発生しない。この時間形式はNon-return to Zero(NRZ)と呼ばれピンは次の繊維まで指定された状態にとどまります。


ピングループ”Data_pins”は各ベクター内で状態を変化させる。Surround by ComplimentやXOR形式のバリエーションで、データバスなどのタイミングをそろえるために利用している



TimeExprはvectorpattenと紐づくのか。。eventが一つのTimeExprの中に複数定義されている場合は変化が前ベクターに従って変化が起こるみたい。
ピングループ”clock_pins”はパタンが1の時にパルス、0の時にはLowのまま。このformatはReturn to Zero(RZ)と呼ばれるもの


DCLevels block
テスタ毎に異なりツール生成なので無視


pattern block
パターンブロックは実際のパタンデータを定義する。

Pattern PatName {
    ( WaveformTableDeclaration | FunctionalVector )* 
}
PatName=ident 
    WaveformTableDeclaration = ( W | WaveformTable ) ident 
    FunctionalVector = ( ParallelVector | LoopVector | MatchVector | Macro | Procedure ) 
    Vector = (F | V) { SigName = ( WFC )+ ; } 
    Condition = C { SigName = ( WFC )+ ; } 
    WFC = (letter | digit | # | %)
} 

Pattern example { 
    W _default_WFT_;  // WaveformTableDeclaration 
    LABEL:  V { ALL = 00000000 00000000 00000000 00000000; }  //FunctionalVector ここから
        V { ALL = 11111111 11111111 11111111 11111111; } 
    Loop 10 { // implemented as a multi-vector loop 
        V { ALL = 11111111 11111111 11111111 11111111; } 
        V { ALL = HHHHHHHH HHHHHHHH HHHHHHHH HHHHHHHH; } 
        V { ALL = 00000000 00000000 00000000 00000000; } 
        V { ALL = LLLLLLLL LLLLLLLL LLLLLLLL LLLLLLLL; } 
    } 
    Loop 5 { // implemented as a repeat vector 
        V { ALL = 11111111 11111111 11111111 11111111; } 
    } 
    Stop; 
}


pattern burst block
パターンのシーケンスを定義。ツールが自動生成するらしい。

PatternBurst BurstName {
 PatList 
 ( PatName ;)* 
}
BurstName = パターンバースト名を表す文字列
PatName = パターンブロックの名前を表す文字列

PatternBurst "_burst_" { 
 PatList { 
 "first_pattern"; 
 } 
} 


PatternExec
patternExecブロックはテスター上でパターンを実行するために必要なすべての部品を定義する接着剤の役割を持つ。
このブロックでは以下の定義を行う
Spec変数の解決に使用するCategory名の定義
selecter nameは変数のどの値（min/typ/max/meas)を適用するか示すセレクタ名
patternexecを実行する前に設定するDClevelsブロック
patternexecを実行するときに使用するAPGSteeringブロック
WaveformTableの参照を見つけるためのTimingブロック
使用するPatternBurst
参照されているTimingまたはDCLevelsブロックに複数のカテゴリを持つSpec変数が含まれている場合、PatternExecブロックに1つ以上のCategory文を指定する必要がある。ちみんｇまたはDCLevelsブロックが複数の値（すなわちMin/Typ/Max）を含むSpec変数を参照する場合、変数はSelectorブロックによってどの値を適用するかを解決、または参照の変数名を装飾する（例えばvar.Minなど）ことによって明確な方法で指定する必要があります。指定されたTimingブロックは参照されるすべてのPatternブロックにおいてWaveformTable名を解決しなければならない。

PatternExecブロックの各項目はオプションです。Spec category、Selector、Timing、DCLevelsのbindに使用することができます。パターンバーストが含まれている場合は、パターンバースト内の各パターンを実行します。

PatternExec (PAT_EXEC_NAME) {
    ( Category CATEGORY_NAME ; )* 
    ( Selector SELECTOR_NAME ; )* 
    ( APGSteering APG_STEERING_NAME; ) 
    ( DCLevels (DC_LEVELS_NAME);) 
    ( Timing TIMING_NAME ; ) 
    ( PatternBurst PAT_BURST_NAME ; ) 
}
CATEGORY_NAME = カテゴリーブロック名の選択。 PatternExecブロックは複数のカテゴリーを持つことができますが、各カテゴリー内の変数は一意なければなりません。
SELECTOR_NAME = セレクタ―ブロック名を選択。複数のセレクタを持つことができるが変数は一意。
APG_STEERING_NAME = DUTピンをAPGリソースに割り当てるAPGSteeringブロックを選択。
DC_LEVELS_NAME = DCLevelブロックを選択ｓ売る。0個または1個ののDC Levelsブロックを含めることができる。
TIMING_NAME = Timingブロックを選択する。0個または1個のTimingブロックを含むことができる。
PAT_BURST_NAME = PatternBurstブロックを選択します。0個または1個のPatternBurstブロックを含むことができる。

PatternExec "FuncExec" { 
    DCLevels "DCLevels"; 
    Timing "Timing"; 
    PatternBurst "FuncBurst"; 
} 



STIL 1.0; 
Signals { 
 DIR In; 
 OE_ In; 
 A0 In; A1 In; A2 In; A3 In; 
 A4 In; A5 In; A6 In; A7 In; 
 B0 Out; B1 Out; B2 Out; B3 Out; 
 B4 Out; B5 Out; B6 Out; B7 Out; 
} 
SignalGroups { 
 ABUS='A7 + A6 + A5 + A4 + A3 + A2 + A1 + A0'; 
 BBUS='B7 + B6 + B5 + B4 + B3 + B2 + B1 + B0'; 
 ALL ='DIR + OE_ + ABUS + BBUS'; 
} 
Timing "basic_timing" { 
 WaveformTable "one" { 
 Period '500ns'; 
 Waveforms { 
 DIR { 01 { '0ns' D/U; }} 
 OE_ { 01 { '0ns' U; '200ns' D/U; '300ns' U; }} 
 ABUS { 01 { '10ns' D/U; }} 
 BBUS { HLZ { '0ns' Z; '0ns' X; '260ns' H/L/T; '280ns' X;}} 
 } 
 } // end WaveformTable one 
} // end Timing "basic_timing" 
PatternBurst "pat1_burst" { 
 PatList { "pattern_1"; 
} // end PatternBurst "pat1_burst" 
PatternExec { 
Timing "basic_timing"; 
 PatternBurst "pat1_burst"; 
} //end PatternExec 
Pattern " pattern_1" { 
 W "one"; 
LAB000: V { ALL=0000000000LLLLLLLL; } // Measure all VOL here 
LAB001: V { ALL=0010000000HLLLLLLL; } // Measure B7 VOH here 
 V { ALL=0001000000LHLLLLLL; } 
 V { ALL=0000100000LLHLLLLL; } 
 V { ALL=0000010000LLLHLLLL; } 
 V { ALL=0000001000LLLLHLLL; } 
 V { ALL=0000000100LLLLLHLL; } 
 V { ALL=0000000010LLLLLLHL; } 
LAB008: V { ALL=0000000001LLLLLLLH; } // Measure B0 VOH here 
Stop; 
} // end Pattern " pattern_1"
